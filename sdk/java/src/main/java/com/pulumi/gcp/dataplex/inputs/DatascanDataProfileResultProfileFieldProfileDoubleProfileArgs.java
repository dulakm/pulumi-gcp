// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.dataplex.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import java.lang.Integer;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class DatascanDataProfileResultProfileFieldProfileDoubleProfileArgs extends com.pulumi.resources.ResourceArgs {

    public static final DatascanDataProfileResultProfileFieldProfileDoubleProfileArgs Empty = new DatascanDataProfileResultProfileFieldProfileDoubleProfileArgs();

    /**
     * Average of non-null values in the scanned data. NaN, if the field has a NaN.
     * 
     */
    @Import(name="average")
    private @Nullable Output<Integer> average;

    /**
     * @return Average of non-null values in the scanned data. NaN, if the field has a NaN.
     * 
     */
    public Optional<Output<Integer>> average() {
        return Optional.ofNullable(this.average);
    }

    /**
     * Maximum of non-null values in the scanned data. NaN, if the field has a NaN.
     * 
     */
    @Import(name="max")
    private @Nullable Output<String> max;

    /**
     * @return Maximum of non-null values in the scanned data. NaN, if the field has a NaN.
     * 
     */
    public Optional<Output<String>> max() {
        return Optional.ofNullable(this.max);
    }

    /**
     * Minimum of non-null values in the scanned data. NaN, if the field has a NaN.
     * 
     */
    @Import(name="min")
    private @Nullable Output<String> min;

    /**
     * @return Minimum of non-null values in the scanned data. NaN, if the field has a NaN.
     * 
     */
    public Optional<Output<String>> min() {
        return Optional.ofNullable(this.min);
    }

    /**
     * A quartile divides the number of data points into four parts, or quarters, of more-or-less equal size. Three main quartiles used are: The first quartile (Q1) splits off the lowest 25% of data from the highest 75%. It is also known as the lower or 25th empirical quartile, as 25% of the data is below this point. The second quartile (Q2) is the median of a data set. So, 50% of the data lies below this point. The third quartile (Q3) splits off the highest 25% of data from the lowest 75%. It is known as the upper or 75th empirical quartile, as 75% of the data lies below this point. Here, the quartiles is provided as an ordered list of quartile values for the scanned data, occurring in order Q1, median, Q3.
     * 
     */
    @Import(name="quartiles")
    private @Nullable Output<String> quartiles;

    /**
     * @return A quartile divides the number of data points into four parts, or quarters, of more-or-less equal size. Three main quartiles used are: The first quartile (Q1) splits off the lowest 25% of data from the highest 75%. It is also known as the lower or 25th empirical quartile, as 25% of the data is below this point. The second quartile (Q2) is the median of a data set. So, 50% of the data lies below this point. The third quartile (Q3) splits off the highest 25% of data from the lowest 75%. It is known as the upper or 75th empirical quartile, as 75% of the data lies below this point. Here, the quartiles is provided as an ordered list of quartile values for the scanned data, occurring in order Q1, median, Q3.
     * 
     */
    public Optional<Output<String>> quartiles() {
        return Optional.ofNullable(this.quartiles);
    }

    /**
     * Standard deviation of non-null values in the scanned data. NaN, if the field has a NaN.
     * 
     */
    @Import(name="standardDeviation")
    private @Nullable Output<Integer> standardDeviation;

    /**
     * @return Standard deviation of non-null values in the scanned data. NaN, if the field has a NaN.
     * 
     */
    public Optional<Output<Integer>> standardDeviation() {
        return Optional.ofNullable(this.standardDeviation);
    }

    private DatascanDataProfileResultProfileFieldProfileDoubleProfileArgs() {}

    private DatascanDataProfileResultProfileFieldProfileDoubleProfileArgs(DatascanDataProfileResultProfileFieldProfileDoubleProfileArgs $) {
        this.average = $.average;
        this.max = $.max;
        this.min = $.min;
        this.quartiles = $.quartiles;
        this.standardDeviation = $.standardDeviation;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(DatascanDataProfileResultProfileFieldProfileDoubleProfileArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private DatascanDataProfileResultProfileFieldProfileDoubleProfileArgs $;

        public Builder() {
            $ = new DatascanDataProfileResultProfileFieldProfileDoubleProfileArgs();
        }

        public Builder(DatascanDataProfileResultProfileFieldProfileDoubleProfileArgs defaults) {
            $ = new DatascanDataProfileResultProfileFieldProfileDoubleProfileArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param average Average of non-null values in the scanned data. NaN, if the field has a NaN.
         * 
         * @return builder
         * 
         */
        public Builder average(@Nullable Output<Integer> average) {
            $.average = average;
            return this;
        }

        /**
         * @param average Average of non-null values in the scanned data. NaN, if the field has a NaN.
         * 
         * @return builder
         * 
         */
        public Builder average(Integer average) {
            return average(Output.of(average));
        }

        /**
         * @param max Maximum of non-null values in the scanned data. NaN, if the field has a NaN.
         * 
         * @return builder
         * 
         */
        public Builder max(@Nullable Output<String> max) {
            $.max = max;
            return this;
        }

        /**
         * @param max Maximum of non-null values in the scanned data. NaN, if the field has a NaN.
         * 
         * @return builder
         * 
         */
        public Builder max(String max) {
            return max(Output.of(max));
        }

        /**
         * @param min Minimum of non-null values in the scanned data. NaN, if the field has a NaN.
         * 
         * @return builder
         * 
         */
        public Builder min(@Nullable Output<String> min) {
            $.min = min;
            return this;
        }

        /**
         * @param min Minimum of non-null values in the scanned data. NaN, if the field has a NaN.
         * 
         * @return builder
         * 
         */
        public Builder min(String min) {
            return min(Output.of(min));
        }

        /**
         * @param quartiles A quartile divides the number of data points into four parts, or quarters, of more-or-less equal size. Three main quartiles used are: The first quartile (Q1) splits off the lowest 25% of data from the highest 75%. It is also known as the lower or 25th empirical quartile, as 25% of the data is below this point. The second quartile (Q2) is the median of a data set. So, 50% of the data lies below this point. The third quartile (Q3) splits off the highest 25% of data from the lowest 75%. It is known as the upper or 75th empirical quartile, as 75% of the data lies below this point. Here, the quartiles is provided as an ordered list of quartile values for the scanned data, occurring in order Q1, median, Q3.
         * 
         * @return builder
         * 
         */
        public Builder quartiles(@Nullable Output<String> quartiles) {
            $.quartiles = quartiles;
            return this;
        }

        /**
         * @param quartiles A quartile divides the number of data points into four parts, or quarters, of more-or-less equal size. Three main quartiles used are: The first quartile (Q1) splits off the lowest 25% of data from the highest 75%. It is also known as the lower or 25th empirical quartile, as 25% of the data is below this point. The second quartile (Q2) is the median of a data set. So, 50% of the data lies below this point. The third quartile (Q3) splits off the highest 25% of data from the lowest 75%. It is known as the upper or 75th empirical quartile, as 75% of the data lies below this point. Here, the quartiles is provided as an ordered list of quartile values for the scanned data, occurring in order Q1, median, Q3.
         * 
         * @return builder
         * 
         */
        public Builder quartiles(String quartiles) {
            return quartiles(Output.of(quartiles));
        }

        /**
         * @param standardDeviation Standard deviation of non-null values in the scanned data. NaN, if the field has a NaN.
         * 
         * @return builder
         * 
         */
        public Builder standardDeviation(@Nullable Output<Integer> standardDeviation) {
            $.standardDeviation = standardDeviation;
            return this;
        }

        /**
         * @param standardDeviation Standard deviation of non-null values in the scanned data. NaN, if the field has a NaN.
         * 
         * @return builder
         * 
         */
        public Builder standardDeviation(Integer standardDeviation) {
            return standardDeviation(Output.of(standardDeviation));
        }

        public DatascanDataProfileResultProfileFieldProfileDoubleProfileArgs build() {
            return $;
        }
    }

}
